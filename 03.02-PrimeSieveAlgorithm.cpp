/*******************************************************
 * File        : 03.02-PrimeSieveAlgorithm.cpp
 * Description : 筛法找素数
 * Author      : Teacher
 * Date        : 2025-04-10
 * Notes       : 
 *      很多个花瓶，进行编号，从2开始往后编，编号后插花，
 *      第一个小朋友，往大于2，且是2的倍数的花瓶插花，
 *      第二个小朋友，往大于3，且是3的倍数的花瓶插花，
 *      以此类推，最后哪些花瓶没有被插花。
 * 
 * 解题思路:
 *      筛子系统的初始化；
 *      枚举2到100^(1/2)的每一个数；
 *          如果d没有被筛掉
 *              用d筛100以内的数；
 *      输出所有没有被筛掉的数；
 *      
 * 注释：
 *      1、只需要从 2 到 √100 的数来筛就够了，为什么呢？
 *          因为超过 √100 的数，它的倍数（比如 11×11 = 121）
 *          已经超出我们要筛的范围了（100 以内），不需要再管。
 * 
 *      2、我们从 d*d 开始筛，不是从 2*d 开始，为啥呢？
 *          因为小于 d 的倍数，比如 2*d, 3*d,... 
 *          都已经被之前的小素数筛掉了。
 *          n = d × k（k ≥ 2）
 *          情况 1: 当 k < d
 *                  n = d × k = k × d
 *                  因为 k < d，所以这个 n 一定在我们处理 k 时，
 *                  已经被筛掉了！所以没必要再用 d 去筛一次。
 *          情况 2: 当 k ≥ d
 *                  此时 n = d × k ≥ d × d
 *                  所以我们从 d*d 开始筛，
 *                  就一定不会漏掉任何需要筛掉的合数。
 *******************************************************/

#include <iostream>
using namespace std;

int main() {

    int num;
    cout << "请输入正整数num:";
    cin >> num;

    bool sieve[num+1];

    for(int i; i <= num; i++)
        sieve[i] = true;

    for(int d = 2; d * d <= num; d++)
        if(sieve[d])
            for(int n = d * d; n <= num; n += d)
                sieve[n] = false;
            
    for(int cnt = 0; cnt <= num; cnt++)
        if(sieve[cnt])
            cout << cnt << ";";
    
    return 0;
}



